/**
 * fingerprint.c -- Routines for creating an n-gram fingerprint of a
 * buffer.
 *
 * A fingerprint is a list of most common n-grams, ordered by
 * frequency. (Note that we can use other strings than n-grams, for
 * instance entire words.)
 *
 * Mar 28, 2003 frank@wise-guys.nl -- created
 *
 * TODO:
 * - put table/heap datastructure in a separate file.
 * */
#include <string.h>
#include <ctype.h>

#include "wglib.h"
#include "wg_mempool.h"

#define INVALID(c) (isspace(c) || isdigit(c)) 

#define TABLEPOW   13
#define TABLESIZE  (1<<TABLEPOW)
#define TABLEMASK  ((TABLESIZE)-1)

#define MAXOUTOFPLACE 400
#define MINDOCSIZE     25

typedef struct {

	sint2 rank;
	char str[6];

} ngram_t;

typedef struct fprint_s {

	const char *name;
	ngram_t *fprint;
	uint4 size;
	
} fprint_t;

typedef struct entry_s {
	char str[6];
	unsigned int cnt;
	struct entry_s *next;
} entry_t;

typedef struct table_s {	
	void *pool;
	entry_t **table;
	entry_t *heap;

	struct table_s *next;
	
	uint4 heapsize;
	uint4 size;
} table_t;



/*
 * fast and furious little hash function
 *
 * (Note that we could use some kind of rolling checksum, and update it
 * during n-gram construction) 
 */
static uint4 simplehash( const char *p, int len )
{
	sint4 h = len * 13;
	while (*p) {
		h = (h<<5)-h + *p++;
	}
	return (uint4)h;
}


/* checks if n-gram lex is a prefix of key and of length len */
inline int issame( char *lex, char *key, int len )
{
	int i;
	for (i=0; i<len; i++) {
		if ( key[i] != lex[i] ) {
			return 0;
		}
	}
	if ( lex[i] != 0 ) {
		return 0;
	}
	return 1;
}


/* increases frequency of ngram(p,len) */
static inline int increasefreq( table_t *t, char *p, int len ) 
{	
	uint4 hash = simplehash( p, len ) & TABLEMASK;				
	entry_t *entry = t->table[ hash ];
	
	wg_debug(NGRAMDEBUG, "%u-GRAM: %s\n", len,p);

	while ( entry ) {				
		if ( issame( entry->str, p, len ) ) {
			/*** Found it! ***/
			entry->cnt++;
			return 1;
		}
		else {
			entry = entry->next;
		}
	}

	/*** Not found, so create ***/
	entry = wgmempool_alloc( t->pool, sizeof(entry_t) );
	strcpy( entry->str, p );
	entry->cnt = 1;

	entry->next = t->table[hash];
	t->table[hash] = entry;

	return 1;
}


/* looks up ngram(p,len) */
static entry_t *findfreq( table_t *t, char *p, int len ) 
{	
	uint4 hash = simplehash( p, len ) & TABLEMASK;				
	entry_t *entry = t->table[ hash ];
	
	while ( entry ) {				
		if ( issame( entry->str, p, len ) ) {
			return entry;
		}
		else {
			entry = entry->next;
		}
	}

	return NULL;
}

static void dumptable(table_t *t)
{
	int i;
	for (i=0; i<TABLESIZE; i++) {

		entry_t *p = t->table[i];

		while (p) {

			printf("%5u %s\n", p->cnt, p->str);
			p = p->next;
		}

	}
}


#define GREATER(x,y) ((x).cnt > (y).cnt)
#define LESS(x,y)    ((x).cnt < (y).cnt)

inline static void siftup( table_t *t, unsigned int child )
{
	entry_t *heap = t->heap;
	unsigned int parent = (child-1) >> 1;
	entry_t tmp;

	while ( child > 0 ) {
		if ( GREATER(heap[parent],heap[child]) ) {
			memcpy( &tmp, &heap[parent], sizeof(entry_t) );
			memcpy( &heap[parent], &heap[child], sizeof(entry_t) );
			memcpy( &heap[child], &tmp, sizeof(entry_t) );
		}
		else {
			return;
		}

		child = parent;
		parent = (child-1) >> 1;
	}
}


inline static void siftdown( table_t *t, unsigned int heapsize, uint4 parent )
{
	entry_t *heap = t->heap;
	unsigned int child = parent*2 + 1;
	entry_t tmp;

	while ( child < heapsize ) {
		if ( child+1 < heapsize && GREATER(heap[child], heap[child+1]) ) {
			child++;
		}
		if ( GREATER(heap[parent], heap[child] ) ) {
			memcpy( &tmp, &heap[parent], sizeof(entry_t) );
			memcpy( &heap[parent], &heap[child], sizeof(entry_t) );
			memcpy( &heap[child], &tmp, sizeof(entry_t) );
		}
		else {
			return;
		}
		parent = child;
		child = (parent*2)+1;
	}
}


static int heapinsert( table_t *t, entry_t *item )
{
	entry_t *heap = t->heap;

	/*** Still room for an entry? ***/
	if (t->size < t->heapsize) {
		memcpy( &(heap[t->size]), item, sizeof(entry_t));
		siftup( t, t->size );
		t->size++;		
		return 0;
	}

	/*** Worse than the worst performer? ***/
	if ( LESS(*item, heap[0]) ) {
		return 0;
	}

	/*** Insert into heap and reheap ***/
	memcpy( &(heap[0]), item, sizeof(entry_t));
	siftdown( t, t->size, 0 );
	return 0;
}


extern int heapextract( table_t *t, entry_t *item )
{
	entry_t *p;

	if (t->size == 0 ) {
		return 0;
	}

	p = &(t->heap[0]);

	memcpy( item, p, sizeof( entry_t ));
	memcpy( &(t->heap[0]), &(t->heap[t->size-1]), sizeof(entry_t) );

	siftdown(t,t->size, 0);
	t->size--;

	return 1;
}


/*** Makes a heap of all table entries ***/
static int table2heap(table_t *t)
{
	int i;
	uint4 cnt = 0;
	uint4 bufsize = 2048;

	/*** Fill result heap ***/
	for (i=0; i<TABLESIZE; i++) {
		entry_t *p = t->table[i];	       
		while (p) {
			heapinsert(t, p);
			p = p->next;
		}
	}     
	return 1;
}


static table_t *inittable(uint4 maxngrams)
{	
	table_t *result = (table_t *)wg_zalloc( sizeof(table_t) );
	result->table = (entry_t **)wg_zalloc( sizeof(entry_t*) * TABLESIZE );
	result->pool = wgmempool_Init( 10000, 10 );

	result->heap = (entry_t *)wg_malloc( sizeof(entry_t) * maxngrams );
	result->heapsize = maxngrams;
	result->size = 0;

	return result;
}

static void tabledone( table_t *t )
{
	if (!t) {
		return;
	}
	wgmempool_Done(t->pool);
	wg_free(t->table);
	wg_free(t->heap);
	wg_free(t);	
}


extern void *fprint_Init(const char *name)
{
	fprint_t *h = (fprint_t *)wg_zalloc( sizeof(fprint_t) );
	
	if ( name ) {
		h->name = wg_strdup(name);
	}

	return (void *)h;
}


extern void fprint_Done( void *handle )
{
	fprint_t *h = (fprint_t *)handle;

	if ( h->name ) {
		wg_free( (void *)h->name );
	}
	if ( h->fprint ) {
		wg_free( h->fprint );
	}

	wg_free( h );
}

extern const char *fprint_Name( void *handle )
{
	fprint_t *h = (fprint_t *)handle;
	return  h->name;
}

/**
 * Function that prepares buffer for n-grammification:
 * runs of invalid characters are collapsed to a single
 * underscore.
 *
 * Function is implemented as a finite state machine.
 */
static char *prepbuffer( const char *src, size_t bufsize )
{
	const char *p = src;
	char *dest = (char *)wg_malloc( bufsize + 3 );
	char *w = dest;
	char *wlimit = dest + bufsize + 1;

 START:
	if ( INVALID(*p) ) {
		goto SPACE;
	}
	else if ( *p == '\0' ) {
		goto END;
	}

	*w++ = '_';
	if ( w == wlimit ) {
		goto STOP;
	}

	goto WORD;


 SPACE:
	/*** Inside string of invalid characters ***/
	p++;
	if ( INVALID(*p) ) {
		goto SPACE;
	}
	else if ( *p == '\0' ) {
		goto END;
	}

	*w++ = '_';
	if ( w == wlimit ) {
		goto STOP;
	}

	goto WORD;

 WORD:
	/*** Inside string of valid characters ***/
	*w++ = *p++;
	if ( w == wlimit ) {
		goto END;
	}
	else if ( INVALID(*p) ) {
		goto SPACE;
	}
	else if ( *p == '\0' ) {
		goto STOP;
	}
	goto WORD;

 END:
	*w++ = '_';

 STOP:
	*w++ = '\0';

	/*** Docs that are too small for a fingerprint, are refused ***/
	if ( w - dest < MINDOCSIZE ) {
		wg_free(dest);
		return NULL;
	}

	return dest;
}


static void createngramtable( table_t *t, const char *buf )
{
	char n[6];
	const char *p = buf;
	int i;

	/*** Get all n-grams where 1<=n<=5. Allow underscores only at borders. ***/
	for (;;p++) {

		const char *q = p;
		char *m = n;

		/*** First char may be an underscore ***/
		*m++ = *q++;
		*m = '\0';

		increasefreq( t, n, 1 );

		if ( *q == '\0' ) {
			return;
		}

		/*** Let the compiler unroll this ***/
		for ( i=2; i<=5; i++) {

			*m++ = *q;
			*m = '\0';

			increasefreq( t, n, i );

			if ( *q == '_' ) break;
			q++;
			if ( *q == '\0' ) {
				return;
			}
		}
	}
	return;
}


static int ngramcmp(const void *a, const void *b)
{
	ngram_t *x = (ngram_t *)a;
	ngram_t *y = (ngram_t *)b;
	
	return strcmp( x->str, y->str );
}

/**
 * Create a fingerprint: 
 * - record the frequency of each unique n-gram in a hash table
 * - take the most frequent n-grams
 * - sort them alphabetically, recording their relative rank
 */
extern int fprint_Create( void *handle, const char *buffer, uint4 bufsize, uint4 maxngrams )
{
	sint4 i;
	fprint_t *h = (fprint_t *)handle;
	table_t *t = inittable(maxngrams);
	char *tmp;

	if ( bufsize < MINDOCSIZE ) {
		return 0;
	}

	/*** Throw out all invalid chars ***/
	tmp = prepbuffer( buffer, bufsize ); 	
	if ( tmp == NULL ) {
		return 0;
	}

	/*** Create a hash table containing n-gram counts ***/
	createngramtable(t, tmp);

	/*** Take the top N n-grams and add them to the profile ***/
	table2heap(t);	
	maxngrams = WGMIN( maxngrams, t->size );       

	h->fprint = (ngram_t *)wg_malloc( sizeof(ngram_t) * maxngrams );
	h->size = maxngrams;

	/*** Pull n-grams out of heap (backwards) ***/
	for (i=maxngrams-1; i>=0; i--) {

		entry_t tmp;

		heapextract(t, &tmp);
		
		/*** the string and its rank is all we need ***/
		strcpy( h->fprint[i].str, tmp.str );
		h->fprint[i].rank = i;
	}

	tabledone(t);
	wg_free(tmp);

	/*** Sort n-grams alphabetically, for easy comparison ***/
	qsort( h->fprint, h->size, sizeof(ngram_t), ngramcmp ); 
	return 1;
}

extern void fprint_Show( void *handle )
{
	fprint_t *h = (fprint_t *)handle;
	int i;
	printf("------ %s --------\n", h->name );
	for (i=0; i<h->size; i++) {
		printf("%3u: '%s' [%u]\n", i, h->fprint[i].str,  h->fprint[i].rank);
	}


}

extern int fprint_Read( void *handle, const char *fname, int maxngrams )
{
	fprint_t *h = (fprint_t *)handle;
	FILE *fp;
	char line[1024];
	int cnt = 0;

	fp = fopen( fname, "r" );
	if (!fp) {
		return 0;
	}
	
	h->fprint = (ngram_t *)wg_malloc(maxngrams * sizeof(ngram_t));

	while (cnt < maxngrams && wg_getline(line,1024,fp)) {

		char *p;

		wg_trim(line, line);

		p = strpbrk( line, " \t" );
		if ( p ) {
			*p = '\0';
		}

		if ( strlen(line) > 5 ) {
			continue;
		}

		strcpy( h->fprint[cnt].str, line );
		h->fprint[cnt].rank = cnt;

		cnt++;
	}

	h->size = cnt;

	/*** Sort n-grams, for easy comparison later on ***/
	qsort( h->fprint, h->size, sizeof(ngram_t), ngramcmp ); 

	fclose(fp);

	return 1;
}


extern sint4 fprint_Compare( void *cat, void *unknown, int cutoff )
{
	fprint_t *c = (fprint_t *)cat;
	fprint_t *u = (fprint_t *)unknown;
	int i = 0;
	int j = 0;
	sint4 sum = 0;
	
	/*** Compare the profiles in mergesort fashion ***/
	while ( i < c->size && j < u->size ) {

		int cmp = strcmp( c->fprint[i].str, u->fprint[j].str );

		if ( cmp < 0 ) {
			i++;
		}
		else if ( cmp == 0 ) {
			sum += abs( c->fprint[i].rank - u->fprint[j].rank );
			if ( sum > cutoff ) {
				return 1000000000;
			}
			i++;
			j++;
		}
		else {
			sum += MAXOUTOFPLACE;
			if ( sum > cutoff ) {
				return 1000000000;
			}
			j++;
		}
	}

	/*** Process tail of unknown, if any ***/
	while ( j < u->size ) {
		sum += MAXOUTOFPLACE;
		if ( sum > cutoff ) {
			return 1000000000;
		}
		j++;
	}

	return sum;
	       	
}


#if 0
int main(int argc, char **argv)
{
	char buf[100 * 1024];
	char tmp[100 * 1024];
	int size;
	fprint_t *h;
	
	wg_meminit();
	{
		//size = fread( buf, 1, 100*1024, stdin );
		h = fprint_Init("test");
		buf[size] = '\0';
		//fprint_Create(h, buf, strlen(buf), 100);
		fprint_Read( h, "/home/frank/textcat/LM/dutch.lm", 100 );
		fprint_Show(h);
		fprint_Done(h);
		wg_printmemstats();
	}
}
#endif
